---
globs: **/auth_providers/**
alwaysApply: false
---
# Airweave Auth Providers

## Overview
Auth providers enable third-party services (Pipedream, Composio) to supply credentials for source connections, eliminating manual credential management and enabling OAuth at scale for agent developers who are already using these connector providers.

## Architecture

### Core Components
```
platform/auth_providers/
├── _base.py              # BaseAuthProvider abstract class
├── pipedream.py          # OAuth2 provider (tokens expire in 3600s)
├── composio.py           # API key provider
└── klavis.py             # Future provider
```

### Provider Registration
```python
@auth_provider(
    name="Pipedream",
    short_name="pipedream",
    auth_type=AuthType.oauth2_with_refresh,
    auth_config_class="PipedreamAuthConfig",
    config_class="PipedreamConfig"
)
class PipedreamAuthProvider(BaseAuthProvider):
    async def create(credentials, config): ...
    async def get_creds_for_source(source_short_name, fields): ...
```

### Field Mappings
Providers map between Airweave and external service naming:
```python
FIELD_NAME_MAPPING = {"api_key": "generic_api_key"}
SLUG_NAME_MAPPING = {"google_drive": "googledrive"}
```

## Integration with TokenManager

The `TokenManager` class orchestrates token refresh during long-running syncs:

### Initialization
```python
# SyncFactory creates TokenManager with optional auth provider
token_manager = TokenManager(
    db=db,
    source_connection=connection,
    auth_provider_instance=auth_provider,  # Optional
    initial_credentials=credentials
)
```

### Refresh Flow
1. **Check refresh capability** (`_determine_refresh_capability()`):
   - Direct injection tokens → no refresh
   - Auth provider present → always refreshable
   - Standard OAuth → attempt refresh

2. **Proactive refresh** (`get_valid_token()`):
   - Refreshes tokens every 25 minutes (before 1-hour expiry)
   - Uses async lock to prevent concurrent refreshes
   - Falls back to stored token if refresh fails

3. **Auth provider refresh** (`_refresh_via_auth_provider()`):
   ```python
   # TokenManager calls auth provider for fresh credentials
   fresh_creds = await auth_provider.get_creds_for_source(
       source_short_name="slack",
       source_auth_config_fields=["access_token", "refresh_token"]
   )
   # Updates database with new credentials
   await crud.integration_credential.update(db, credential, fresh_creds)
   ```

4. **Fallback OAuth refresh** (`_refresh_via_oauth()`):
   - Uses oauth2_service if no auth provider
   - Handles white-label credentials
   - Creates separate DB session to avoid transaction issues

### Credential Priority (in SyncFactory)
1. Direct token injection (highest)
2. Auth provider instance
3. Database credentials with OAuth refresh

## Database Schema
- **auth_providers**: Provider definitions from decorators
- **auth_provider_connections**: User's configured providers (encrypted)
- **source_connections**: Links to auth provider via `auth_provider_connection_id`
# Airweave Auth Providers

## Overview
Auth providers enable third-party services (Pipedream, Composio) to supply credentials for source connections, eliminating manual credential management and enabling OAuth at scale for agent developers who are already using these connector providers.

## Architecture

### Core Components
```
platform/auth_providers/
├── _base.py              # BaseAuthProvider abstract class
├── pipedream.py          # OAuth2 provider (tokens expire in 3600s)
├── composio.py           # API key provider
└── klavis.py             # Future provider
```

### Provider Registration
```python
@auth_provider(
    name="Pipedream",
    short_name="pipedream",
    auth_type=AuthType.oauth2_with_refresh,
    auth_config_class="PipedreamAuthConfig",
    config_class="PipedreamConfig"
)
class PipedreamAuthProvider(BaseAuthProvider):
    async def create(credentials, config): ...
    async def get_creds_for_source(source_short_name, fields): ...
```

### Field Mappings
Providers map between Airweave and external service naming:
```python
FIELD_NAME_MAPPING = {"api_key": "generic_api_key"}
SLUG_NAME_MAPPING = {"google_drive": "googledrive"}
```

## Integration with TokenManager

The `TokenManager` class orchestrates token refresh during long-running syncs:

### Initialization
```python
# SyncFactory creates TokenManager with optional auth provider
token_manager = TokenManager(
    db=db,
    source_connection=connection,
    auth_provider_instance=auth_provider,  # Optional
    initial_credentials=credentials
)
```

### Refresh Flow
1. **Check refresh capability** (`_determine_refresh_capability()`):
   - Direct injection tokens → no refresh
   - Auth provider present → always refreshable
   - Standard OAuth → attempt refresh

2. **Proactive refresh** (`get_valid_token()`):
   - Refreshes tokens every 25 minutes (before 1-hour expiry)
   - Uses async lock to prevent concurrent refreshes
   - Falls back to stored token if refresh fails

3. **Auth provider refresh** (`_refresh_via_auth_provider()`):
   ```python
   # TokenManager calls auth provider for fresh credentials
   fresh_creds = await auth_provider.get_creds_for_source(
       source_short_name="slack",
       source_auth_config_fields=["access_token", "refresh_token"]
   )
   # Updates database with new credentials
   await crud.integration_credential.update(db, credential, fresh_creds)
   ```

4. **Fallback OAuth refresh** (`_refresh_via_oauth()`):
   - Uses oauth2_service if no auth provider
   - Handles white-label credentials
   - Creates separate DB session to avoid transaction issues

### Credential Priority (in SyncFactory)
1. Direct token injection (highest)
2. Auth provider instance
3. Database credentials with OAuth refresh

## Database Schema
- **auth_providers**: Provider definitions from decorators
- **auth_provider_connections**: User's configured providers (encrypted)
- **source_connections**: Links to auth provider via `auth_provider_connection_id`
